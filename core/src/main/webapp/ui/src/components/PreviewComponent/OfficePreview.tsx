/**
 * OfficePreview Component for NemakiWare React UI
 *
 * Office document preview component that displays PDF renditions generated by LibreOffice:
 * - Fetches PDF renditions from the rendition API
 * - If no rendition exists, triggers generation and waits for completion
 * - Displays the PDF using PDFPreview component (react-pdf)
 * - Shows loading state during rendition fetch/generation
 * - Falls back to download-only mode if rendition generation fails
 * - Japanese fonts supported via fonts-noto-cjk in Docker container
 */

import React, { useState, useEffect } from 'react';
import { Alert, Button, Space, Spin, message } from 'antd';
import { DownloadOutlined, FileTextOutlined, ReloadOutlined } from '@ant-design/icons';
import { CMISService } from '../../services/cmis';
import { useAuth } from '../../contexts/AuthContext';
import { PDFPreview } from './PDFPreview';

interface OfficePreviewProps {
  url: string;
  fileName: string;
  mimeType: string;
  repositoryId?: string;
  objectId?: string;
}

export const OfficePreview: React.FC<OfficePreviewProps> = ({
  url,
  fileName,
  mimeType,
  repositoryId,
  objectId
}) => {
  const { handleAuthError } = useAuth();
  const cmisService = new CMISService(handleAuthError);

  const [loading, setLoading] = useState(true);
  const [renditionUrl, setRenditionUrl] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [generating, setGenerating] = useState(false);
  const [blobUrl, setBlobUrl] = useState<string | null>(null);

  // Cleanup blob URL on unmount
  useEffect(() => {
    return () => {
      if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
      }
    };
  }, [blobUrl]);

  /**
   * Fetch PDF content with authentication and create a blob URL
   * This is necessary because react-pdf can't use token-based auth URLs directly
   */
  const fetchPdfAsBlob = async (repoId: string, objId: string, streamId: string): Promise<string | null> => {
    try {
      console.log('[OfficePreview] Fetching PDF as blob with auth headers...');
      const pdfBlob = await cmisService.getRenditionContent(repoId, objId, streamId);
      const blobUrlCreated = URL.createObjectURL(pdfBlob);
      console.log('[OfficePreview] Created blob URL:', blobUrlCreated);
      return blobUrlCreated;
    } catch (err) {
      console.error('[OfficePreview] Error fetching PDF as blob:', err);
      return null;
    }
  };

  const getFileTypeDescription = (mimeType: string) => {
    if (mimeType.includes('wordprocessingml')) return 'Word文書';
    if (mimeType.includes('spreadsheetml')) return 'Excel文書';
    if (mimeType.includes('presentationml')) return 'PowerPoint文書';
    if (mimeType.includes('opendocument.text')) return 'OpenDocument テキスト';
    if (mimeType.includes('opendocument.spreadsheet')) return 'OpenDocument スプレッドシート';
    if (mimeType.includes('opendocument.presentation')) return 'OpenDocument プレゼンテーション';
    return 'オフィス文書';
  };

  // Extract repositoryId and objectId from URL if not provided
  const extractFromUrl = (url: string): { repoId: string | null; objId: string | null } => {
    // URL format: /core/browser/{repositoryId}/node/{objectId}/content
    const match = url.match(/\/core\/browser\/([^/]+)\/node\/([^/]+)/);
    if (match) {
      return { repoId: match[1], objId: match[2] };
    }
    return { repoId: null, objId: null };
  };

  const fetchRenditions = async () => {
    const { repoId, objId } = extractFromUrl(url);
    const effectiveRepoId = repositoryId || repoId;
    const effectiveObjId = objectId || objId;

    if (!effectiveRepoId || !effectiveObjId) {
      setError('レンディション取得に必要な情報が不足しています');
      setLoading(false);
      return;
    }

    try {
      const renditions = await cmisService.getRenditions(effectiveRepoId, effectiveObjId);
      console.log('[OfficePreview] Renditions:', renditions);

      // Find PDF rendition
      const pdfRendition = renditions.find((r: any) =>
        r.mimeType === 'application/pdf' ||
        r.contentMimeType === 'application/pdf'
      );

      if (pdfRendition) {
        const streamId = pdfRendition.streamId || pdfRendition.renditionDocumentId;
        if (streamId) {
          console.log('[OfficePreview] PDF rendition found with streamId:', streamId);
          // Fetch PDF as blob with auth headers (react-pdf can't use token-based URLs directly)
          const pdfBlobUrl = await fetchPdfAsBlob(effectiveRepoId, effectiveObjId, streamId);
          if (pdfBlobUrl) {
            setBlobUrl(pdfBlobUrl);
            setRenditionUrl(pdfBlobUrl);
            setError(null);
          } else {
            setError('PDFコンテンツの取得に失敗しました');
          }
        } else {
          setError('PDFレンディションのストリームIDが見つかりません');
        }
      } else {
        // No PDF rendition found - try to generate one
        console.log('[OfficePreview] No PDF rendition found, attempting to generate...');
        await generateRendition(effectiveRepoId, effectiveObjId);
      }
    } catch (err) {
      console.error('[OfficePreview] Error fetching renditions:', err);
      setError('レンディションの取得に失敗しました');
    } finally {
      setLoading(false);
    }
  };

  const generateRendition = async (repoId: string, objId: string) => {
    setGenerating(true);
    console.log(`[OfficePreview] Starting rendition generation for repo=${repoId}, objId=${objId}`);
    try {
      const generateResult = await cmisService.generateRenditions(repoId, objId, false);
      console.log('[OfficePreview] Generate rendition result:', generateResult);
      message.info('PDFレンディションを生成中...');

      // Wait a bit and then poll for the rendition
      await new Promise(resolve => setTimeout(resolve, 5000));

      // Fetch renditions again
      console.log('[OfficePreview] Fetching renditions after generation...');
      const renditions = await cmisService.getRenditions(repoId, objId);
      console.log('[OfficePreview] Renditions after generation:', renditions);

      const pdfRendition = renditions.find((r: any) =>
        r.mimeType === 'application/pdf' ||
        r.contentMimeType === 'application/pdf'
      );

      if (pdfRendition) {
        const streamId = pdfRendition.streamId || pdfRendition.renditionDocumentId;
        console.log('[OfficePreview] Found PDF rendition with streamId:', streamId);
        if (streamId) {
          // Fetch PDF as blob with auth headers (react-pdf can't use token-based URLs directly)
          const pdfBlobUrl = await fetchPdfAsBlob(repoId, objId, streamId);
          if (pdfBlobUrl) {
            console.log('[OfficePreview] Rendition blob URL created:', pdfBlobUrl);
            setBlobUrl(pdfBlobUrl);
            setRenditionUrl(pdfBlobUrl);
            setError(null);
            message.success('PDFレンディションの生成が完了しました');
          } else {
            console.error('[OfficePreview] Failed to fetch PDF content');
            setError('PDFコンテンツの取得に失敗しました');
          }
        } else {
          console.error('[OfficePreview] PDF rendition found but no streamId:', pdfRendition);
          setError('PDFレンディションのストリームIDが見つかりません');
        }
      } else {
        console.error('[OfficePreview] No PDF rendition found after generation. Available renditions:', renditions);
        setError('PDFレンディションの生成に時間がかかっています。しばらく待ってから再試行してください。');
      }
    } catch (err: any) {
      console.error('[OfficePreview] Error generating rendition:', err);
      console.error('[OfficePreview] Error details:', err.message, err.status, err.response);
      setError(`PDFレンディションの生成に失敗しました: ${err.message || '不明なエラー'}`);
    } finally {
      setGenerating(false);
    }
  };

  const handleRetry = async () => {
    const { repoId, objId } = extractFromUrl(url);
    const effectiveRepoId = repositoryId || repoId;
    const effectiveObjId = objectId || objId;

    if (effectiveRepoId && effectiveObjId) {
      setLoading(true);
      setError(null);
      await generateRendition(effectiveRepoId, effectiveObjId);
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchRenditions();
  }, [url, repositoryId, objectId]);

  // Loading state
  if (loading || generating) {
    return (
      <div style={{ textAlign: 'center', padding: '60px' }}>
        <Spin size="large" />
        <p style={{ marginTop: '16px', color: '#666' }}>
          {generating ? 'PDFレンディションを生成中...' : 'プレビューを読み込み中...'}
        </p>
      </div>
    );
  }

  // If we have a rendition URL, show the PDF preview
  if (renditionUrl) {
    return (
      <div data-testid="office-preview-pdf">
        <PDFPreview url={renditionUrl} fileName={`${fileName}.pdf`} />
      </div>
    );
  }

  // Fallback: Download-only mode when rendition is not available
  return (
    <div style={{ textAlign: 'center', padding: '40px' }} data-testid="office-preview-fallback">
      <FileTextOutlined style={{ fontSize: '64px', color: '#1890ff', marginBottom: '24px' }} />
      <Alert
        message={error || 'オフィス文書のプレビュー'}
        description={
          <Space direction="vertical" size="large">
            <div>
              <p><strong>{fileName}</strong></p>
              <p>{getFileTypeDescription(mimeType)}</p>
            </div>
            {error ? (
              <p>プレビューの生成に失敗しました。再試行するか、ダウンロードしてローカルアプリケーションでご確認ください。</p>
            ) : (
              <p>オフィス文書のプレビューは現在サポートされていません。<br />ダウンロードしてローカルアプリケーションでご確認ください。</p>
            )}
            <Space>
              {error && (
                <Button
                  icon={<ReloadOutlined />}
                  onClick={handleRetry}
                >
                  再試行
                </Button>
              )}
              <Button
                type="primary"
                icon={<DownloadOutlined />}
                onClick={() => window.open(url, '_blank')}
                size="large"
              >
                ダウンロード
              </Button>
            </Space>
          </Space>
        }
        type={error ? 'warning' : 'info'}
        showIcon={false}
      />
    </div>
  );
};
