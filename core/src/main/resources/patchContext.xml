<?xml version="1.0" encoding="UTF-8"?>
<!-- This context file needs in another file: ContentService/PrincipalService/TypeService
	bean definition -->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
 xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config />
	<!-- Component scanning for jp.aegif.nemaki.patch intentionally disabled to prevent conflicts -->
	<!-- PatchService is registered as explicit bean definition below instead -->
	<!-- Component scanning for jp.aegif.nemaki.init intentionally disabled to prevent conflicts -->
	<!-- CMISPostInitializer is registered as explicit bean definition below instead -->

	<!--
		Phase 2: CMIS Post-Initializer (New Architecture)

		CRITICAL FIX: Changed from InitializingBean to ContextRefreshedEvent
		Uses @EventListener to execute CMIS operations AFTER entire Spring context
		is fully initialized, ensuring TypeManager and all services are operational.
		This prevents "TYPES is empty" errors during patch execution.
	-->
	<bean id="cmisPostInitializer" class="jp.aegif.nemaki.init.CMISPostInitializer">
		<property name="cmisPatchList">
			<list>
				<!-- CRITICAL: System folder must be created first for other patches to work -->
				<bean class="jp.aegif.nemaki.patch.Patch_SystemFolderSetup">
					<property name="patchUtil">
						<ref bean="patchUtil" />
					</property>
				</bean>
				<!-- Initial content setup: Sites, Technical Documents folders and CMIS spec PDF -->
				<!-- MUST run after SystemFolderSetup but before any caching initialization -->
				<bean class="jp.aegif.nemaki.patch.Patch_InitialContentSetup">
					<property name="patchUtil">
						<ref bean="patchUtil" />
					</property>
				</bean>
				<!-- CMIS-specific patches that require running services -->
				<bean class="jp.aegif.nemaki.patch.Patch_StandardCmisViews">
					<property name="patchUtil">
						<ref bean="patchUtil" />
					</property>
				</bean>
				<!-- Initial users and groups: testgroup, testuser with firstName/lastName -->
				<!-- Enhanced version with proper user properties -->
				<bean class="jp.aegif.nemaki.patch.Patch_TestUserInitialization">
					<property name="patchUtil">
						<ref bean="patchUtil" />
					</property>
				</bean>
			</list>
		</property>
	</bean>

	<!--
		PHASE 3: PatchService - ApplicationListener via Explicit Bean Definition

		Similar to CMISPostInitializer, PatchService is registered as an explicit bean
		to ensure proper ApplicationListener registration in the child context.
		@Component scanning alone does not guarantee ApplicationListener registration
		in NemakiApplicationContextLoader's child context.

		Execution order managed by Spring's @Order(3) annotation in PatchService.java.
	-->
	<!--
		CRITICAL DISCOVERY (2025-11-10): Spring does not automatically create beans in child context
		unless they have properties or init-method. CMISPostInitializer works because it has
		cmisPatchList property. Adding init-method="initializeIfNeeded" to force bean creation.

		COMPLETE FIX: init-method forces bean instantiation, properties provide required dependencies
	-->
	<bean id="patchService" class="jp.aegif.nemaki.patch.PatchService" init-method="initializeIfNeeded">
		<property name="repositoryInfoMap"><ref bean="repositoryInfoMap" /></property>
		<property name="connectorPool"><ref bean="connectorPool" /></property>
		<property name="propertyManager"><ref bean="propertyManager" /></property>
		<property name="typeService"><ref bean="typeService" /></property>
		<property name="typeManager"><ref bean="TypeManager" /></property>
		<property name="contentService"><ref bean="ContentService" /></property>
		<property name="solrUtil"><ref bean="solrUtil" /></property>
	</bean>

	<bean id="patchUtil" class="jp.aegif.nemaki.patch.PatchUtil">
		<property name="propertyManager">
			<ref bean="propertyManager" />
		</property>
		<property name="repositoryInfoMap">
			<ref bean="repositoryInfoMap" />
		</property>
		<property name="contentDaoService">
			<ref bean="ContentDaoService" />
		</property>
		<property name="contentService">
			<ref bean="ContentService" />
		</property>
		<property name="connectorPool">
			<ref bean="connectorPool" />
		</property>
		<property name="repositoryService">
			<ref bean="RepositoryService" />
		</property>
		<property name="typeService">
			<ref bean="TypeService" />
		</property>
		<property name="typeManager">
			<ref bean="TypeManager" />
		</property>
		<property name="solrUtil">
			<ref bean="solrUtil" />
		</property>
	</bean>

	<!-- Individual Patch Bean Definitions for ServletContextListener access -->
	<!-- CRITICAL: These beans are also used by ServletContextListener for reliable patch execution -->

	<bean id="patch_SystemFolderSetup" class="jp.aegif.nemaki.patch.Patch_SystemFolderSetup">
		<property name="patchUtil">
			<ref bean="patchUtil" />
		</property>
	</bean>

	<bean id="patch_InitialContentSetup" class="jp.aegif.nemaki.patch.Patch_InitialContentSetup">
		<property name="patchUtil">
			<ref bean="patchUtil" />
		</property>
	</bean>

	<bean id="patch_StandardCmisViews" class="jp.aegif.nemaki.patch.Patch_StandardCmisViews">
		<property name="patchUtil">
			<ref bean="patchUtil" />
		</property>
	</bean>

	<bean id="patch_TestUserInitialization" class="jp.aegif.nemaki.patch.Patch_TestUserInitialization">
		<property name="patchUtil">
			<ref bean="patchUtil" />
		</property>
	</bean>

</beans>
